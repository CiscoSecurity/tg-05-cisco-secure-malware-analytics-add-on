import { splunkdPath } from '@splunk/splunk-utils/config'
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'

export const fetchInputs = createAsyncThunk(
  'fetchInputs',
  async () => await fetch(
      `${splunkdPath}/servicesNS/nobody/tg-05-splunk-add-on/TA_cisco_threat_grid_tg?count=-1&output_mode=json`,
      {
        method: 'GET'
      }
  ).then((response) => response.json())
)

// export const deleteInput = createAsyncThunk(
//   'deleteInput',
//   async (
//     { name, acl: { owner, app }, content: { stream_name } },
//     { getState, dispatch }
//   ) => {
//     try {
//       const { apiId, apiHost, apiKey } = getState()?.configuration.data
//
//       const response = await fetch(
//         `/custom/amp4e_events_input/amp_streams_api_controller/delete_stream?api_host=${apiHost}&api_id=${apiId}&api_key=${apiKey}&name=${name}`,
//         {
//           method: 'DELETE'
//         }
//       ).then((response) => response.json())
//
//       if (response.error) {
//         console.info('There is been an error', response.error)
//         dispatch(showErrorMessage('There is been an error.'))
//         return
//       }
//
//       await fetch(
//         `${splunkdPath}/servicesNS/${owner}/${app}/data/inputs/amp4e_events_input/${encodeURIComponent(
//           name
//         )}`,
//         {
//           method: 'DELETE',
//           headers: defaultFetchInit.headers
//         }
//       )
//
//       return { success: response.success, name, streamName: stream_name }
//     } catch (e) {
//       console.info('Could not delete the input.')
//     }
//   }
// )

const initialState = {
  inputs: {
    data: [],
    pending: false,
    perPage: 10,
    pages: 1,
    currentPage: 1
  },
}

export const inputsSlice = createSlice({
  name: 'inputs',
  initialState,
  reducers: {
    setPerPageOption(state, action) {
      state.inputs.perPage = action.payload
    }
  },
  extraReducers: async (builder) => {
    builder.addCase(fetchInputs.pending, (state) => {
      state.inputs = {
        ...state.inputs,
        pending: true
      }
    })
    builder.addCase(fetchInputs.fulfilled, (state, action) => {
      state.inputs = {
        ...state.inputs,
        data: action.payload.entry,
        pending: false,
        pages: Math.ceil(action.payload.entry.length / state.inputs.perPage)
      }
    })
    // builder.addCase(deleteInput.fulfilled, (state, action) => {
    //   if (action.payload?.success) {
    //     console.info('Search deleted')
    //     state.inputs = {
    //       data: state.inputs.data.filter(
    //         ({ name }) => name !== action.payload.name
    //       ),
    //       pending: false
    //     }
    //   }
    // })
  }
})

export const {
  setPerPageOption
} = inputsSlice.actions

export default inputsSlice.reducer
