import { splunkdPath } from '@splunk/splunk-utils/config'
import { defaultFetchInit } from '@splunk/splunk-utils/fetch'
import { createAsyncThunk, createSlice, isAnyOf } from '@reduxjs/toolkit'
import { omit } from 'lodash'

export const fetchInputs = createAsyncThunk(
  'fetchInputs',
  async () => await fetch(
      `${splunkdPath}/servicesNS/nobody/tg-05-splunk-add-on/TA_cisco_threat_grid_tg?count=-1&output_mode=json`,
      {
        method: 'GET'
      }
  ).then((response) => response.json())
)

export const fetchIndexes = createAsyncThunk(
  'fetchIndexes',
  async () => await fetch(
      `${splunkdPath}/servicesNS/nobody/tg-05-splunk-add-on/data/indexes?output_mode=json&count=-1`,
      {
        method: 'GET'
      }
  ).then((response) => response.json())
)

export const createInput = createAsyncThunk(
  'createInput',
  async (data, { dispatch }) => await fetch(
      `${splunkdPath}/servicesNS/nobody/tg-05-splunk-add-on/TA_cisco_threat_grid_tg?output_mode=json`,
      {
        method: 'POST',
        body: new URLSearchParams(data),
        headers: defaultFetchInit.headers
      }
  ).then(() => dispatch(fetchInputs()))
)

export const changeInputStatus = createAsyncThunk(
  'changeInputStatus',
  async ({ name, disabled }, { dispatch }) => await fetch(
      `${splunkdPath}/servicesNS/nobody/tg-05-splunk-add-on/TA_cisco_threat_grid_tg/${name}?output_mode=json`,
      {
        method: 'POST',
        body: new URLSearchParams({ disabled }),
        headers: defaultFetchInit.headers
      }
  ).then(() => dispatch(fetchInputs()))
)

export const editInput = createAsyncThunk(
  'editInput',
  async (input, { dispatch }) => await fetch(
      `${splunkdPath}/servicesNS/nobody/tg-05-splunk-add-on/TA_cisco_threat_grid_tg/${input.name}?output_mode=json`,
      {
        method: 'POST',
        body: new URLSearchParams(omit(input, ['name'])),
        headers: defaultFetchInit.headers
      }
  ).then(() => dispatch(fetchInputs()))
)

export const deleteInput = createAsyncThunk(
  'deleteInput',
  async (input, { dispatch }) => await fetch(
      `${splunkdPath}/servicesNS/nobody/tg-05-splunk-add-on/TA_cisco_threat_grid_tg/${input.name}?output_mode=json`,
      {
        method: 'DELETE',
        headers: defaultFetchInit.headers
      }
  ).then(() => dispatch(fetchInputs()))
)

// export const deleteInput = createAsyncThunk(
//   'deleteInput',
//   async (
//     { name, acl: { owner, app }, content: { stream_name } },
//     { getState, dispatch }
//   ) => {
//     try {
//       const { apiId, apiHost, apiKey } = getState()?.configuration.data
//
//       const response = await fetch(
//         `/custom/amp4e_events_input/amp_streams_api_controller/delete_stream?api_host=${apiHost}&api_id=${apiId}&api_key=${apiKey}&name=${name}`,
//         {
//           method: 'DELETE'
//         }
//       ).then((response) => response.json())
//
//       if (response.error) {
//         console.info('There is been an error', response.error)
//         dispatch(showErrorMessage('There is been an error.'))
//         return
//       }
//
//       await fetch(
//         `${splunkdPath}/servicesNS/${owner}/${app}/data/inputs/amp4e_events_input/${encodeURIComponent(
//           name
//         )}`,
//         {
//           method: 'DELETE',
//           headers: defaultFetchInit.headers
//         }
//       )
//
//       return { success: response.success, name, streamName: stream_name }
//     } catch (e) {
//       console.info('Could not delete the input.')
//     }
//   }
// )

const initialState = {
  inputs: {
    data: [],
    pending: false,
    perPage: 10,
    pages: 1,
    currentPage: 1
  },
  indexes: []
}

export const inputsSlice = createSlice({
  name: 'inputs',
  initialState,
  reducers: {
    setPerPageOption(state, action) {
      state.inputs.perPage = action.payload
      state.inputs.pages = Math.ceil(state.inputs.data.length / action.payload)
      state.inputs.currentPage = 1
    },
    setPage(state, action) {
      state.inputs.currentPage = action.payload
    }
  },
  extraReducers: async (builder) => {
    builder.addCase(fetchInputs.pending, (state) => {
      state.inputs = {
        ...state.inputs,
        pending: true
      }
    })
    builder.addCase(fetchInputs.fulfilled, (state, action) => {
      state.inputs = {
        ...state.inputs,
        data: action.payload.entry,
        pending: false,
        pages: Math.ceil(action.payload.entry.length / state.inputs.perPage)
      }
    })
    builder.addCase(fetchIndexes.pending, (state) => {
      state.indexes = {
        ...state.indexes,
        pending: true
      }
    })
    builder.addCase(fetchIndexes.fulfilled, (state, action) => {
      state.indexes = {
        ...state.indexes,
        data: action.payload.entry,
        pending: false,
      }
    })
    builder.addCase(createInput.pending, (state) => {
      state.inputs.pending = true
    })
    builder.addMatcher(
      isAnyOf(createInput.rejected, createInput.fulfilled),
      (state) => {
        state.inputs.pending = false
      }
    )
    builder.addCase(editInput.pending, (state) => {
      state.inputs.pending = true
    })
    builder.addMatcher(
      isAnyOf(editInput.rejected, editInput.fulfilled),
      (state) => {
        state.inputs.pending = false
      }
    )
    builder.addCase(changeInputStatus.pending, (state) => {
      state.inputs.pending = true
    })
    builder.addMatcher(
      isAnyOf(changeInputStatus.rejected, changeInputStatus.fulfilled),
      (state) => {
        state.inputs.pending = false
      }
    )
    // builder.addCase(deleteInput.fulfilled, (state, action) => {
    //   if (action.payload?.success) {
    //     console.info('Search deleted')
    //     state.inputs = {
    //       data: state.inputs.data.filter(
    //         ({ name }) => name !== action.payload.name
    //       ),
    //       pending: false
    //     }
    //   }
    // })
  }
})

export const {
  setPerPageOption,
  setPage
} = inputsSlice.actions

export default inputsSlice.reducer
