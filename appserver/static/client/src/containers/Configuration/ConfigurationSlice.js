import { createAsyncThunk, createSlice, isAnyOf } from '@reduxjs/toolkit'
import { app, splunkdPath } from '@splunk/splunk-utils/config'
import { defaultFetchInit } from '@splunk/splunk-utils/fetch'

const apiPath = `${splunkdPath}/servicesNS/nobody/${app}`
const settingsUrl = 'TA_cisco_secure_malware_analytics_settings'

export const fetchProxy = createAsyncThunk('fetchProxy', () => {
  try {
    return fetch(
      `${apiPath}/${settingsUrl}/proxy?output_mode=json`,
      { method: 'GET' }
    ).then((response) => response.json())
  } catch (e) {
    console.error(e)
  }
})

export const saveProxy = createAsyncThunk('saveProxy', (data) => {
  try {
    return fetch(
      `${apiPath}/${settingsUrl}/proxy?output_mode=json`,
      {
        method: 'POST',
        body: new URLSearchParams({ ...data, proxy_enabled: data.proxy_enabled ? 1 : 0 }),
        headers: defaultFetchInit.headers
      }
    ).then((response) => response.json())
  } catch (e) {
    console.error(e)
  }
})

export const saveLogging = createAsyncThunk('saveLogging', (data) => {
  try {
    return fetch(
      `${apiPath}/${settingsUrl}/logging?output_mode=json`,
      {
        method: 'POST',
        body: new URLSearchParams(data),
        headers: defaultFetchInit.headers
      }
    ).then((response) => response.json())
  } catch (e) {
    console.error(e)
  }
})

export const fetchLogging = createAsyncThunk('fetchLogging', () => {
  try {
    return fetch(
      `${apiPath}/${settingsUrl}/logging?output_mode=json`,
      { method: 'GET' }
    ).then((response) => response.json())
  } catch (e) {
    console.error(e)
  }
})

const initialState = {
  proxy: {},
  logging: {},
  pending: false
}

export const configurationSlice = createSlice({
  name: 'configuration',
  initialState,
  extraReducers: async (builder) => {
    builder.addMatcher(
      isAnyOf(fetchProxy.pending, fetchLogging.pending, saveProxy.pending, saveLogging.pending),
      (state) => {
        state.pending = true
      }
    )
    builder.addMatcher(
      isAnyOf(saveProxy.fulfilled, saveLogging.fulfilled),
      (state) => {
        state.pending = false
      }
    )
    builder.addCase(fetchProxy.fulfilled, (state, { payload }) => {
      state.proxy = payload.entry[0]
      state.pending = false
    })
    builder.addCase(fetchLogging.fulfilled, (state, { payload }) => {
      state.logging = payload.entry[0]
      state.pending = false
    })
  }
})

export default configurationSlice.reducer
