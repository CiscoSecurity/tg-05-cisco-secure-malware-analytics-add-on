import { createAsyncThunk, createSlice, isAnyOf } from '@reduxjs/toolkit'
import { app, splunkdPath } from '@splunk/splunk-utils/config'
import { defaultFetchInit } from '@splunk/splunk-utils/fetch'
import { omit } from 'lodash'

const apiPath = `${splunkdPath}/servicesNS/nobody/${app}`
const accountsUrl = 'TA_cisco_secure_malware_analytics_account'

export const fetchAccounts = createAsyncThunk(
  'fetchAccounts',
  async () => await fetch(
      `${apiPath}/${accountsUrl}?count=-1&output_mode=json`,
      {
        method: 'GET'
      }
  ).then((response) => response.json())
)

export const createAccount = createAsyncThunk(
  'createAccount',
  async (data, { dispatch }) => await fetch(
      `${apiPath}/${accountsUrl}?output_mode=json`,
      {
        method: 'POST',
        body: new URLSearchParams(data),
        headers: defaultFetchInit.headers
      }
  ).then(() => dispatch(fetchAccounts()))
)

export const editAccount = createAsyncThunk(
  'editAccount',
  async (account, { dispatch }) => await fetch(
      `${apiPath}/${accountsUrl}/${account.name}?output_mode=json`,
      {
        method: 'POST',
        body: new URLSearchParams(omit(account, ['name'])),
        headers: defaultFetchInit.headers
      }
  ).then(() => dispatch(fetchAccounts()))
)

export const deleteAccount = createAsyncThunk(
  'deleteAccount',
  async (account, { dispatch }) => await fetch(
      `${apiPath}/${accountsUrl}/${account.name}?output_mode=json`,
      {
        method: 'DELETE',
        headers: defaultFetchInit.headers
      }
  ).then(() => dispatch(fetchAccounts()))
)

const initialState = {
  accounts: {
    data: [],
    pending: false,
    perPage: 10,
    pages: 1,
    currentPage: 1
  }
}

export const accountsSlice = createSlice({
  name: 'accounts',
  initialState,
  reducers: {
    setAccountsPerPageOption(state, action) {
      state.accounts.perPage = action.payload
      state.accounts.pages = Math.ceil(state.accounts.data.length / action.payload)
      state.accounts.currentPage = 1
    },
    setAccountsPage(state, action) {
      state.accounts.currentPage = action.payload
    }
  },
  extraReducers: async (builder) => {
    builder.addCase(fetchAccounts.pending, (state) => {
      state.accounts = {
        ...state.accounts,
        pending: true
      }
    })
    builder.addCase(fetchAccounts.fulfilled, (state, action) => {
      state.accounts = {
        ...state.accounts,
        data: action.payload.entry,
        pending: false,
        pages: Math.ceil(action.payload.entry.length / state.accounts.perPage)
      }
    })
    builder.addMatcher(
      isAnyOf(
        createAccount.rejected,
        createAccount.fulfilled,
        editAccount.rejected,
        editAccount.fulfilled,
        deleteAccount.rejected,
        deleteAccount.fulfilled
      ),
      (state) => {
        state.accounts.pending = false
      }
    )
    builder.addMatcher(
      isAnyOf(createAccount.pending, editAccount.pending, deleteAccount.pending),
      (state) => {
        state.accounts.pending = true
      }
    )
  }
})

export const {
  setAccountsPerPageOption,
  setAccountsPage
} = accountsSlice.actions

export default accountsSlice.reducer
